# script created by KSB, 08.08.18
# Perform DE analysing relationship between islands using RUVs as batch correction method

# Load dependencies and set input paths --------------------------

# Load dependencies:
library(edgeR)
library(plyr)
library(NineteenEightyR)
library(RColorBrewer)
library(biomaRt)
library(ggpubr)
library(ggplot2)
library(ggsignif)
library(pheatmap)
library(viridis)
library(gplots)
library(circlize)
library(ComplexHeatmap)
library(Homo.sapiens)


# Set paths:
inputdir = "/Users/katalinabobowik/Documents/UniMelb_PhD/Analysis/UniMelb_Sumba/Output/DE_Analysis/123_combined/"

# Set output directory and create it if it does not exist:
outputdir <- "/Users/katalinabobowik/Documents/UniMelb_PhD/Analysis/UniMelb_Sumba/Output/DE_Analysis/123_combined/DE_Island/RUVs/"

if (file.exists(outputdir) == FALSE){
    dir.create(outputdir)
}

# set up colour palette. The "wes" palette will be used for island and other statistical information, whereas NineteenEightyR will be used for batch information
wes=c("#3B9AB2", "#EBCC2A", "#F21A00", "#00A08A", "#ABDDDE", "#000000", "#FD6467","#5B1A18")
palette(c(wes, brewer.pal(8,"Dark2")))
# set up colour palette for batch
batch.col=electronic_night(n=3)
dev.off()

# Begin Analysis --------------------------------------------------------------------------------------------------

# Load the RUVs-corrected object
load(paste0(inputdir, "RUVs_Setup/set1_RUVsCorrectedObject.Rda"))
# load the filtered, normalised y DGE list object
load(paste0(inputdir, "dataPreprocessing/indoRNA.read_counts.TMM.filtered.Rda"))

# define sample names
samplenames <- as.character(y$samples$samples)
samplenames <- sub("([A-Z]{3})([0-9]{3})", "\\1-\\2", samplenames)
samplenames <- sapply(strsplit(samplenames, "[_.]"), `[`, 1)

# define variables
batch=y$samples$batch
Island=y$samples$Island

design <- model.matrix(~0 + Island + W_1 + W_2 + W_3 + W_4 + W_5, data=pData(set1))
colnames(design)=gsub("Island", "", colnames(design))
colnames(design)[3]="Mappi"
z <- DGEList(counts=counts(set1), group=Island)
# normalise data with UQ normalisation (as per previous method on seqExpressionSet object)
z <- calcNormFactors(z, method="upperquartile")
# add in genes to the DGEList for downstream use
geneid <- rownames(z)
genes <- select(Homo.sapiens, keys=geneid, columns=c("SYMBOL", "TXCHROM"), keytype="ENSEMBL")
genes <- genes[!duplicated(genes$ENSEMBL),]
z$genes <- genes

# stuff I'm not sure if I need --------------------------------------------------------------

# look at performance of normalisation
# Duplicate data, set normalisation back to 1, and plot difference between normalised and non-normalised data
pdf(paste0(outputdir,"NormalisedGeneExpressionDistribution_IndoRNA.pdf"), height=15, width=15)
par(oma=c(2,0,0,0), mfrow=c(2,1))
z2 <- z
z2$samples$norm.factors <- 1
lcpm <- cpm(z2, log=TRUE)
boxplot(lcpm, las=2, col=batch.col[as.numeric(batch)], main="", cex.axis=0.75, names=samplenames)
title(main="A. Unnormalised data",ylab="Log-cpm")
z2 <- calcNormFactors(z2, method="upperquartile")
lcpm <- cpm(z2, log=TRUE)
boxplot(lcpm, las=2, col=batch.col[as.numeric(batch)], main="", cex.axis=0.75, names=samplenames)
title(main="B. Normalised data, UpperQuartile",ylab="Log-cpm")
dev.off()

# get density plot after normalisation
pdf(paste0(outputdir,"densityPlot_NormalisedGeneExpressionDistribution_IndoRNA.pdf"))
nsamples <- ncol(z)
plot(density(lcpm[,1]), col=batch.col[batch][1], lwd=2, ylim=c(0,max(density(lcpm)$y)+.2), las=2, main="", xlab="")
title(main="Filtered data \n Post-Normalisation", xlab="Log-cpm")
abline(v=0, lty=3)
for (i in 2:nsamples){
    den <- density(lcpm[,i])
    lines(den$x, den$y, col=batch.col[batch][i], lwd=2)
}
legend("topright", legend=c("First Batch","Second Batch", "Third Batch"), ncol=1, cex=0.8, text.col=batch.col[unique(batch)], bty="n")
dev.off()

# We can view how UQ normalisation performed using MD plots. This visualizes the library size-adjusted log-fold change between
# two libraries (the difference) against the average log-expression across those libraries (themean). MD plots are generated by comparing sample 1 against an artificial
# library constructed from the average of all other samples. Ideally, the bulk of genes should be centred at a log-fold change of zero.  This indicates
# that any composition bias between libraries has been successfully removed

pdf(paste0(outputdir,"MDPlots_UQNormalisation_Outliers.pdf", height=15, width=15))
par(mfrow=c(4,4))
for (i in 1:ncol(z)){
  plotMD(cpm(z, log=TRUE), column=i)
  abline(h=0, col="red", lty=2, lwd=2)
}
dev.off()

# Estimate dispersion. The trend in NB dispersions should decrease smoothly with increasing abundance.  
# This is because the expression of high-abundance genes is expected to be more stable than that of low-abundance genes. 
# Any substantial increase at high abundances may be indicative of batch effects or trended biases.
z <- estimateDisp(z, design, robust=TRUE)
pdf(paste0(outputdir,"plotBCV_NBDispersion.pdf"))
plotBCV(z)
dev.off()

# save the normalised z object
save(z, file = paste0(outputdir, "z_UQNormalised.Rda"))

# Linear modelling --------------------------------------------------------------------------

# set up contrast matrix
contr.matrix <- makeContrasts(SMBvsMTW=Sumba - Mentawai, SMBvsMPI=Sumba - Mappi, MTWvsMPI=Mentawai - Mappi, levels=colnames(design))

# now run voom and see how it performs
pdf(paste0(outputdir,"Limma_voom_upperquartilenormalisation.pdf", height=8, width=15))
par(mfrow = c(1,2))
v <- voom(z, design, plot=TRUE, cex.main=2, cex.axis=1.7, cex.lab=1.7)

# create a new variable for blocking using sample IDs
z$samples$ind <- samplenames

# Estimate the correlation between the replicates.
# Information is borrowed by constraining the within-block corre-lations to be equal between genes and by using empirical Bayes methods to moderate the standarddeviations between genes 
dupcor <- duplicateCorrelation(v, design, block=z$samples$ind)
# The value dupcor$consensus estimates the average correlation within the blocks and should be positive
dupcor$consensus # sanity check
#  0.2858893
median(v$weights) # another sanity check:
# 17.84776

# run voom a second time with the blocking variable and estimated correlation
# The  vector y$samples$ind indicates the  two  blocks  corresponding  to  biological  replicates
pdf(paste0(outputdir,"RUV_voomDuplicateCorrelation.pdf"), height=8, width=12)
par(mfrow=c(1,2))
vDup <- voom(z, design, plot=TRUE, block=z$samples$ind, correlation=dupcor$consensus, cex.main=2, cex.axis=1.7, cex.lab=1.7)
dupcor <- duplicateCorrelation(vDup, design, block=z$samples$ind) # get warning message: Too much damping - convergence tolerance not achievable
dupcor$consensus # sanity check pt 2
# [1] 0.2866048
median(vDup$weights) # another sanity check, pt 2 
# [1] 17.83832

# With duplicate correction and blocking:
# the inter-subject correlation is input into the linear model fit
voomDupVfit <- lmFit(vDup, design, block=z$samples$ind, correlation=dupcor$consensus)
voomDupVfit <- contrasts.fit(voomDupVfit, contrasts=contr.matrix)
voomDupEfit <- eBayes(voomDupVfit, robust=T)

plotSA(voomDupEfit, main="Mean-variance trend elimination with duplicate correction")
dev.off()

# save duplicated efit object
save(voomDupEfit, file="voomDupEfit_RUVs.Rda")

# get top genes using toptable
voomDupTopTableSMB.MTW <- topTable(voomDupEfit, coef=1, p.value=0.01, n=Inf, sort.by="p")
voomDupTopTableSMB.MPI <- topTable(voomDupEfit, coef=2, p.value=0.01, n=Inf, sort.by="p")
voomDupTopTableMTW.MPI <- topTable(voomDupEfit, coef=3, p.value=0.01, n=Inf, sort.by="p")

# get number of DE genes at differnet thresholds
# noLFC
summary(decideTests(voomDupEfit, method="separate", adjust.method = "BH", p.value = 0.01))
#       SMBvsMTW SMBvsMPI MTWvsMPI
#Down       3021     1495      892
#NotSig     8090     9761    10494
#Up         1864     1719     1589

# LFC of 0.5
summary(decideTests(voomDupEfit, method="separate", adjust.method = "BH", p.value = 0.01, lfc=0.5))
#       SMBvsMTW SMBvsMPI MTWvsMPI
#Down        206      285      313
#NotSig    12466    12021    12112
#Up          303      669      550

# LFC of 1
summary(decideTests(voomDupEfit, method="separate", adjust.method = "BH", p.value = 0.01, lfc=1))
#       SMBvsMTW SMBvsMPI MTWvsMPI
#Down          8       58       87
#NotSig    12939    12761    12729
#Up           28      156      159

# get all logFC thresholds
logFC.df=matrix(nrow=3,ncol=3)
colnames(logFC.df)=colnames(voomDupEfit)
counter=0
for (number in c(0,0.5,1)){
    counter=counter+1
    dt <- decideTests(voomDupEfit, p.value=0.01, lfc=number)
    values=c(sum(abs(dt[,1])), sum(abs(dt[,2])), sum(abs(dt[,3])))
    logFC.df[counter,]=values
}
logFC.df=cbind(logFC = c(0,0.5,1), logFC.df)
write.table(logFC.df, file=paste0(outputdir,"logFC_thresholds.txt"))


# fit linear models without duplicate correlation ------------------
vfit <- lmFit(v, design)
vfit <- contrasts.fit(vfit, contrasts=contr.matrix)
efit <- eBayes(vfit)

# get all logFC thresholds
logFC.df.efit=matrix(nrow=3,ncol=3)
colnames(logFC.df.efit)=colnames(efit)
counter=0
for (number in c(0,0.5,1)){
    counter=counter+1
    dt <- decideTests(efit, p.value=0.01, lfc=number)
    values=c(sum(abs(dt[,1])), sum(abs(dt[,2])), sum(abs(dt[,3])))
    logFC.df.efit[counter,]=values
}
logFC.df.efit=cbind(logFC = c(0,0.5,1), logFC.df.efit)
write.table(logFC.df.efit, file=paste0(outputdir,"logFC_thresholds_noDupCor.txt"))


# Summary and visualisation of gene trends using duplicate correlation results ---------------------------------------------------------------------------

dt <- decideTests(voomDupEfit, p.value=0.01, lfc=1)

# plot log2 fold change between islands
pdf(paste0(outputdir,"log2FC_IslandComparisons_pval01_dupCor.pdf"))
# note 'p.value' is the cutoff value for adjusted p-values
topTable <- topTable(voomDupEfit, coef=1, n=Inf, p.value=0.01)
plot(density(topTable$logFC), col=9, xlim=c(-2,2), main="LogFC Density", xlab="LogFC", ylab="Density")
abline(v=c(-1,-0.5,0.5,1), lty=3)
counter=0
for (i in 2:ncol(voomDupEfit)){
    counter=counter+1
    topTable <- topTable(voomDupEfit, coef=i, n=Inf, p.value=0.01)
    lines(density(topTable$logFC), col=9+counter, xlim=c(-2,2))
}
legend(x="topright", bty="n", col=9:11, legend=colnames(voomDupEfit), lty=1, lwd=2)
dev.off()

# graphical representation of DE results through MD plot
pdf(paste0(outputdir,"MD_Plots_pval01_lfc1_dupCor.pdf"), height=15, width=10)
par(mfrow=c(3,1))
for (i in 1:ncol(voomDupEfit)){
    o <- which(names(voomDupEfit$Amean) %in% names(which(abs(dt[,i])==1)))
    x <- voomDupEfit$Amean
    z <- voomDupEfit$coefficients[,i]
    t=which(names(voomDupEfit$coefficients[,i]) %in% names(which(abs(dt[,i])==1)))
    G <- voomDupEfit$genes[names(which(abs(dt[,i])==1)),]$SYMBOL
    plotMD(voomDupEfit, column=i, status=dt[,i], main=colnames(voomDupEfit)[i], hl.col=c("blue","red"), values=c(-1,1))
    abline(h=c(1,-1), lty=2)
    legend(legend=paste(names(summary(dt)[,i]), summary(dt)[,i], sep="="), x="bottomright", border=F, bty="n")
    text(x[o], z[t], labels=G)
}
dev.off()

# We can also look at the top ten DE genes with a heatmap of logCPM values for the top 100 genes. Each gene (or row) is scaled so that mean expression is zero and the standard deviation is one (we're using 'E' from the voom object which is a numeric matrix of normalized expression values on the log2 scale). Samples with relatively high expression of a given gene are marked in red and samples with relatively low expression are marked in blue. Lighter shades and white represent genes with intermediate expression levels. Samples and genes are reordered by the method of hierarchical clustering
# first, make a heatmap of all top genes in one pdf

# reset ensemble row names to gene symbols
rownames(vDup$E)=vDup$genes$SYMBOL

# set up annotation
col_fun = colorRamp2(c(-4, 0, 4), c("blue", "white", "red"))

df1=data.frame(island = as.character(Island))
df2=data.frame(batch = as.numeric(batch))
ha1 = HeatmapAnnotation(df = df1, col = list(island = c("Mentawai" =  1, "Sumba" = 2, "West Papua" = 3)))

pdf(paste0(outputdir,"HeatmapAllPops_dupCor.pdf"), height=15, width=15)
grid.newpage()
pushViewport(viewport(layout = grid.layout(nr = 2, nc = 2)))
# set up layout row position
layout.row=c(1,1,2)
# set up column position
layout.col=c(1,2,1)

for (i in 1:ncol(voomDupEfit)){
    topTable <- topTable(voomDupEfit, coef=i, p.value=0.01, lfc=1, n=Inf, sort.by="p")
    index <- which(voomDupEfit$genes$ENSEMBL %in% topTable$ENSEMBL[1:10])
    pushViewport(viewport(layout.pos.row = layout.row[i], layout.pos.col = layout.col[i]))
    draw(Heatmap(t(scale(t(vDup$E[index,]))), col=col_fun, column_title = colnames(voomDupEfit)[i], top_annotation = ha1, show_row_names = T, show_heatmap_legend = F, show_column_names = F, name = "Z-Score"),show_annotation_legend = FALSE,newpage=F)
    upViewport()

}

lgd = Legend(at = c(-4,0,4), title = "Row Z-Score", col_fun = col_fun, grid_height = unit(1, "cm"), grid_width = unit(10, "mm"))
lgd2 = Legend(at = c(1,2,3), legend_gp = gpar(fill = 1:3), labels=c("Mentawai", "Sumba","West Papua"),title = "Island", grid_height = unit(1, "cm"), grid_width = unit(10, "mm"))
pd = packLegend(lgd, lgd2, direction = "horizontal")

pushViewport(viewport(layout.pos.row = 2, layout.pos.col = 2))
grid.draw(pd)
upViewport()
dev.off()

# We can also make individual pdfs of the top genes
island1=c("Sumba","Mentawai","West Papua")
island2=c("Sumba","Mentawai","West Papua")

counter=0

for (i1 in island1){
    island2=island2[-1]
    for (i2 in island2){
        counter=counter+1
        topTable <- topTable(voomDupEfit, coef=counter, p.value=0.01, lfc=1, n=Inf, sort.by="p")
        index <- which(vDup$genes$ENSEMBL %in% topTable$ENSEMBL[1:10])
        df=data.frame(island = as.character(Island[grep(paste(i1,i2,sep="|"), Island)]))
        ha =  HeatmapAnnotation(df = df, col = list(island = c("Mentawai" =  1, "Sumba" = 2, "West Papua" = 3)))
        pdf(paste0(outputdir,"HeatmapTopeGenes_",i1,"_vs_",i2,"_dupCor.pdf"), height=10, width=15)
        draw(Heatmap(t(scale(t(vDup$E[index,])))[,grep(paste(i1,i2,sep="|"), Island)], col=col_fun, column_title = colnames(voomDupEfit)[counter], top_annotation = ha, show_row_names = T, show_heatmap_legend = T, show_column_names = F, name = "Z-Score"),show_annotation_legend = TRUE,newpage=F)
        dev.off()
    }
}

# show the number of DE genes between all islands
pdf(paste0(outputdir,"vennDiagram_allSigDEGenes_pval01_FDR1_dupCor.pdf"), height=15, width=15)
vennDiagram(dt[,1:3], circle.col=c(9,10,11))
dev.off()

# get DE genes in common with populations compared to Mappi, i.e., SMBvsMPI and MTWvsMPI (since we think this is an interesting island comparison)
rownames(voomDupEfit$genes)=voomDupEfit$genes$ENSEMBL
de.common.MPI = which(dt[,2]!=0 & dt[,3]!=0)
# get what these genes are doing and save them to a file
ensembl.mart.90 <- useMart(biomart='ENSEMBL_MART_ENSEMBL', dataset='hsapiens_gene_ensembl', host = 'www.ensembl.org', ensemblRedirect = FALSE)
commonGenes.MPI <- getBM(attributes = c('ensembl_gene_id', 'external_gene_name', 'description', "interpro","interpro_description"), mart = ensembl.mart.90,values=names(de.common.MPI), filters="ensembl_gene_id")
write.table(de.common.MPI, file=paste0(outputdir,"allCommonGenes_MPI_dupcor.txt"))
# save the common gene names 
de.common.MPI=voomDupEfit$genes[names(de.common.MPI),]

# now plot the common genes to see if they're being regulated in the same direction
tt.SMBvsMPI=topTable(voomDupEfit, coef=2, p.value=0.01, n=Inf, lfc=1, sort.by="p")
tt.MTWvsMPI=topTable(voomDupEfit, coef=3, p.value=0.01, n=Inf, lfc=1, sort.by="p")
pdf(paste0(outputdir,"logFC_commonMPIgenes_dupCor.pdf"))
plot(tt.SMBvsMPI[rownames(de.common.MPI),"logFC"], tt.MTWvsMPI[rownames(de.common.MPI),"logFC"], xlab="logFC SMBvsMPI", ylab="logFC MTWvsMPI", pch=20, main="Common DE Genes", xlim=c(-5,5), ylim=c(-6,6))
text(tt.SMBvsMPI[rownames(de.common.MPI),"logFC"], tt.MTWvsMPI[rownames(de.common.MPI),"logFC"], labels=tt.SMBvsMPI[rownames(de.common.MPI),"SYMBOL"], pos=3)
abline(h=0,v=0, lty=2)
dev.off()

# top ranked genes -----------------------------------------------------------------------------------------

# Let's see how the expression levels of all of the significantly DE genes in population comparisons with Mappi are distributed within each island. First, assign our top genes and ensembl IDs to variables
topGenes=de.common.MPI[,2]
topEnsembl=de.common.MPI[,1]

# To visualise distributions, we'll be making violin plots using ggpubr which needs p-value labels. Let's go ahead and make a matrix to input this into ggpubr
# first set up matrix
topGenes.pvalue=matrix(nrow=length(topEnsembl), ncol=ncol(voomDupEfit))
rownames(topGenes.pvalue)=topEnsembl
colnames(topGenes.pvalue)=colnames(voomDupEfit)
for (i in 1:ncol(voomDupEfit)){
    # get significant genes over a logFC of 1 for all Island comparisons
    topTable <- topTable(voomDupEfit, coef=i, n=Inf)
    for(j in topEnsembl){
        # input the adjusted p.value for each gene
        topGenes.pvalue[j,i]=topTable[j,"adj.P.Val"]
    }
}

# make pvalues into scientific notation with max 3 digits
topGenes.pvalue=formatC(topGenes.pvalue, format="e", digits=2, drop0trailing=T)
# convert e notation to base 10 notation
topGenes.pvalue=sub("e", "x10^", topGenes.pvalue)

# We can make the violin plots using ggpubr
pdf(paste0(outputdir,"TopGenes_ggboxplot_Island.pdf"), height=8, width=10)
counter=0
for(ensembl in topEnsembl){
    counter=counter+1
    gene.df <- data.frame(vDup$E[which(vDup$genes$ENSEMBL==ensembl),],Island)
    colnames(gene.df)=c("CPM", "Island")
    annotation_df <- data.frame(start=c("Sumba","Sumba", "Mentawai"), end=c("Mentawai","West Papua","West Papua"), y=c(max(gene.df[,1]+4),max(gene.df[,1]+5),max(gene.df[,1]+6)), label=paste("limma p-value =",topGenes.pvalue[ensembl,],sep=" "))
    print(ggviolin(gene.df, x = "Island", y = "CPM", fill="Island", add=c("jitter","boxplot"), main=topGenes[counter], palette=1:3, add.params = c(list(fill = "white"), list(width=0.05))) + geom_signif(data=annotation_df,aes(xmin=start, xmax=end, annotations=label, y_position=y),textsize = 5, vjust = -0.2,manual=TRUE) + ylim(NA, max(gene.df[,1])+7))
}
dev.off()

# after analysing the distributions and reading up on some of the genes, my three favourite genes are Siglec6, Siglec7, and MARCO. Lets plot out the distribution solely for these three genes
favGenes=c("SIGLEC6","SIGLEC7","MARCO")
#"RSAD2","AIM2","TNFSF4")
favEnsembl=de.common.MPI[,1][sapply(1:length(favGenes), function(x) grep(favGenes[x],de.common.MPI[,2]))]

# set up pvalue matrix
topGenes.pvalue=matrix(nrow=length(favEnsembl), ncol=ncol(voomDupEfit))
rownames(topGenes.pvalue)=favEnsembl
colnames(topGenes.pvalue)=colnames(voomDupEfit)
for (i in 1:ncol(voomDupEfit)){
    # get significant genes over a logFC of 1 for all Island comparisons
    topTable <- topTable(voomDupEfit, coef=i, n=Inf)
    for(j in favEnsembl){
        # input the adjusted p.value for each gene
        topGenes.pvalue[j,i]=topTable[j,"adj.P.Val"]
    }
}

# make pvalues into scientific notation with max 3 digits
topGenes.pvalue=formatC(topGenes.pvalue, format="e", digits=2, drop0trailing=T)
# convert e notation to base 10 notation
topGenes.pvalue=sub("e", "x10^", topGenes.pvalue)

# We can make the violin plots using ggpubr
counter=0
for(ensembl in favEnsembl){
    counter=counter+1
    # pdf(paste0("FavouriteGenes_ggboxplot_",favGenes[counter],".pdf"), height=8, width=10)
    gene.df <- data.frame(vDup$E[which(vDup$genes$ENSEMBL==ensembl),],Island)
    colnames(gene.df)=c("CPM", "Island")
    annotation_df <- data.frame(start=c("Sumba","Sumba", "Mentawai"), end=c("Mentawai","West Papua","West Papua"), y=c(max(gene.df[,1]+4),max(gene.df[,1]+5),max(gene.df[,1]+6)), label=paste("limma p-value =",topGenes.pvalue[ensembl,],sep=" "))
    # print(ggviolin(gene.df, x = "Island", y = "CPM", fill="Island", add=c("jitter","boxplot"), main=favGenes[counter], palette=1:3, add.params = c(list(fill = "white"), list(width=0.05))) + geom_signif(data=annotation_df,aes(xmin=start, xmax=end, annotations=label, y_position=y),textsize = 5, vjust = -0.2,manual=TRUE) + ylim(NA, max(gene.df[,1])+7))
    assign(favGenes[counter], ggviolin(gene.df, x = "Island", y = "CPM", fill="Island", add=c("jitter","boxplot"), main=favGenes[counter], palette=1:3, add.params = c(list(fill = "white"), list(width=0.05))) + geom_signif(data=annotation_df,aes(xmin=start, xmax=end, annotations=label, y_position=y),textsize = 3, vjust = -0.2,manual=TRUE) + ylim(NA, max(gene.df[,1])+7))
}

pdf(paste0(outputdir,"favouriteTopGenes_distribution_Island.pdf"), height=12, width=15)
ggarrange(SIGLEC6,SIGLEC7,MARCO)
#AIM2,TNFSF4,RSAD2)
dev.off()


# Enrichment analysis for Gene Ontology ----------------------------------------------------------------------------------------------------

# transform ensembl IDs to entrez IDs to be compatible with human c2 dataset (below)
#ensembl_genes=rownames(z)
#entrez=getBM(filters= "ensembl_gene_id", attributes= c("ensembl_gene_id", "entrezgene", "description"),values= ensembl_genes,mart=ensembl.mart.90)
#z$entrezID=entrez[match(rownames(z), entrez[,1]), 2]

# gene set testing with Camera
#load(url("http://bioinf.wehi.edu.au/software/MSigDB/human_c2_v5p2.rdata")) 
#idx <- ids2indices(Hs.c2,id=z$entrezID) 
#for (i in 1:ncol(contr.matrix)){
#    camera.matrix=camera(v,idx,design,contrast=contr.matrix[,i])
#    write.table(camera.matrix, file=paste0("cameraMatrix_",colnames(contr.matrix)[i],".txt"))
#}

# gene set testing with goSeq
#for(pop in 1:ncol(efit)){
#    for(pval in c(0.05, 0.01)){
#        topTable <- topTable(efit, coef=pop, n=Inf, p.value=pval, lfc=1)
#        gene.vector=as.integer(rownames(z) %in% rownames(topTable))
#        names(gene.vector)=rownames(z)
#
#        # set the probability weighting fcuntion, i.e., implement a weight for each gene dependent on its length
#        pwf=nullp(gene.vector,"hg19","ensGene")
#        # use  the  default  method  to  calculate  the  over  and  under  expressed  GO categories among DE genes
#        GO.wall=goseq(pwf,"hg19","ensGene",use_genes_without_cat=TRUE)

        # now let's interpret the results. First we need to apply a multiple hypothesis testing correction set at 5% (BH method)
#        enriched.GO=GO.wall[p.adjust(GO.wall$over_represented_pvalue, method="BH")<.05,]
#        write.table(enriched.GO, file=paste("enrichedGOterms",colnames(efit)[pop],pval,".txt", sep="_"), quote=F, row.names=F)
#        if(nrow(enriched.GO)>0){
#            zz=file(paste("topTen_enrichedGOterms",pop,pval,".txt", sep="_"), open="wt")
#            sink(zz)
#            sink(zz, type = "message")
#            # get GO terms for top ten enriched GO terms - write output with the sink() function
#            for(go in 1:length(enriched.GO$category)){
#                print(GOTERM[[enriched.GO$category[go]]])
#            }
#        }
#        sink(type = "message")
#        sink()
#
#        # KEGG pathway analysis
#        en2eg=as.list(org.Hs.egENSEMBL2EG)
#        # Get the mapping from Entrez 2 KEGG
#        eg2kegg=as.list(org.Hs.egPATH)
#        # Define a function which gets all unique KEGG IDs
#        # associated with a set of Entrez IDs
#        grepKEGG=function(id,mapkeys){unique(unlist(mapkeys[id],use.names=FALSE))}
#        # Apply this function to every entry in the mapping from
#        # ENSEMBL 2 Entrez to combine the two maps
#        kegg=lapply(en2eg,grepKEGG,eg2kegg)

        # produce PWF as before
#        pwf=nullp(gene.vector,"hg19","ensGene")
#        KEGG=goseq(pwf,gene2cat=kegg, use_genes_without_cat=TRUE)
#        enriched.GO.kegg=KEGG[p.adjust(KEGG$over_represented_pvalue, method="BH")<.05,]
#        write.table(enriched.GO.kegg, file=paste("enrichedGOkegg",pop,pval,".txt", sep="_"))
#    }
#}

# Enrichment Visualisation ----------------------------------------------------------------------------------------------------


# Having played around with many visualisation options, it seems as though using Revigo is the best and most user-friendly. Using the output from the GoSeq enriched Go results (FDR <0.05), we can plug our GO IDs into Revigo (http://revigo.irb.hr/) and then output this as an R script.
# First save  output (remember that SMBvsMTW has no significantly enriched GO pathways so we'll only do this for SMBvsMPI and MTWvsMPI)  

# Revigo for MTW vs MPI (pval of 0.05 FDR)- Treemap
#source("/Users/katalinabobowik/Documents/UniMelb_PhD/Analysis/UniMelb_Sumba/Scripts/GIT/SEA_RegulatoryVariation/code/Differential_Expression/123_combined/REVIGO_MTWvsMPI_Treemap.r")
# scatterplot
#source("/Users/katalinabobowik/Documents/UniMelb_PhD/Analysis/UniMelb_Sumba/Scripts/GIT/SEA_RegulatoryVariation/code/Differential_Expression/123_combined/REVIGO_MTWvsMPI_Scatterplot.r")

# Revigo for SMB vs MPI (pval of 0.05 FDR)- Treemap
#source("/Users/katalinabobowik/Documents/UniMelb_PhD/Analysis/UniMelb_Sumba/Scripts/GIT/SEA_RegulatoryVariation/code/Differential_Expression/123_combined/REVIGO_SMBvsMPI_Treemap.r")
# scatterplot
#source("/Users/katalinabobowik/Documents/UniMelb_PhD/Analysis/UniMelb_Sumba/Scripts/GIT/SEA_RegulatoryVariation/code/Differential_Expression/123_combined/REVIGO_SMBvsMPI_Scatterplot.r")

# Reactome --------------------------------------------------
# get what the top genes are doing from Reactome
#for (i in 1:ncol(efit)){
#    topTable <- topTable(efit, coef=i, p.value=0.01, lfc=1, n=Inf)
#    entrez=getBM(filters= "ensembl_gene_id", attributes= c("ensembl_gene_id", "entrezgene"),values= rownames(topTable),mart=ensembl.mart.90)
#    de <- entrez[,2]
#    x <- enrichPathway(gene=de,pvalueCutoff=0.05, readable=T)
#    if(nrow(x) > 0){
#        pdf(paste0("enriched_pathways_reactome_",colnames(efit)[i],"PopComparisons.pdf"), height=5, width=10)
#        print(barplot(x, showCategory=nrow(x), font.size = 8, title = colnames(efit)[i]))
#        dev.off()
#    }
#}

#writeLines(capture.output(sessionInfo()), "sessionInfo.txt")
