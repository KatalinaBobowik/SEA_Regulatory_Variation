# script created by KSB, 08.08.18
# Perform DE analysing relationship between villages

# load dependencies: libraries, human count data, plasmodium data, and data preprocessing
source("/Users/katalinabobowik/Documents/UniMelb_PhD/Analysis/UniMelb_Sumba/Scripts/GIT/SEA_Regulatory_Variation/code/Differential_Expression/123_combined/countData_123_combined.R")
source("/Users/katalinabobowik/Documents/UniMelb_PhD/Analysis/UniMelb_Sumba/Scripts/GIT/SEA_Regulatory_Variation/code/Differential_Expression/123_combined/dataPreprocessing_123_combined.R")

# load libraries
library(UpSetR)

# set working directory
setwd("/Users/katalinabobowik/Documents/UniMelb_PhD/Analysis/UniMelb_Sumba/Output/DE_Analysis/123_combined/DE_Village")

# Removing heteroscedascity with voom and fitting linear models -----------------------------------------------------------------------

# First, remove samples that have less than ten individuals per village
table(Sampling.Site)
# Sampling.Site
#   Anakalung    Bilarenge    Hupu Mada      Madobag        Mappi  Padira Tana 
#          20            1            5           17           21            3 
# Patiala Bawa        Rindi     Taileleu        Wunga   Wura Homba 
#           1            5           32           17            1 

# remove Bilarenge, Hupu Mada, Padira Tana, Patiala Bawa, Rindi, and Wura Homba
y=y[,-grep("Bilarenge|Hupu Mada|Padira Tana|Patiala Bawa|Rindi|Wura Homba", y$samples$Sampling.Site)]
# drop unused levels
y$samples=droplevels(y$samples)

# set up designs
design <- model.matrix(~0 + y$samples$Sampling.Site + y$samples$Age + y$samples$batch + y$samples$RIN + y$samples$CD8T + y$samples$CD4T + y$samples$NK + y$samples$Bcell + y$samples$Mono + y$samples$Gran)
# Get rid of 'Sampling Site' and 'y$samples' from column names
colnames(design)=gsub("Sampling.Site", "", colnames(design))
colnames(design)=gsub("[\\y$]", "", colnames(design))
colnames(design)=gsub("samples", "", colnames(design))

# set up contrast matrix
contr.matrix <- makeContrasts(ANKvsMDB=Anakalung-Madobag, ANKvsMPI=Anakalung-Mappi, ANKvsTLL=Anakalung-Taileleu, ANKvsWNG=Anakalung-Wunga, MDBvsMPI=Madobag-Mappi, MDBvsTLL=Madobag-Taileleu, MDBvsWNG=Madobag-Wunga, MPIvsTLL=Mappi-Taileleu, MPIvsWNG=Mappi-Wunga, TLLvsWNG=Taileleu-Wunga, levels=colnames(design))

# now go ahead with voom normalisation
pdf("Limma_voom_TMMNormalisation.pdf", height=8, width=12)
par(mfrow=c(ncol=1,nrow=2))
v <- voom(y, design, plot=TRUE)
# fit linear models
vfit <- lmFit(v, design)
vfit <- contrasts.fit(vfit, contrasts=contr.matrix)
efit <- eBayes(vfit, robust=T)
plotSA(efit, main="Mean-variance trend elimination")
dev.off()

# We can view how UQ normalisation performed using MD plots. This visualizes the library size-adjusted log-fold change between
# two libraries (the difference) against the average log-expression across those libraries (themean). MD plots are generated by comparing sample 1 against an artificial
# library constructed from the average of all other samples. Ideally, the bulk of genes should be centred at a log-fold change of zero.  This indicates
# that any composition bias between libraries has been successfully removed

pdf("MDPlots_TMM_Normalisation_OutliersCheck.pdf", height=15, width=15)
par(mfrow=c(4,4))
for (i in 1:ncol(y)){
  plotMD(cpm(y, log=TRUE), column=i)
  abline(h=0, col="red", lty=2, lwd=2)
}
dev.off()

# QC after fitting linear models --------------------------------------------------------------------------------------

# check to see p-value distribution is normal
pdf("PvalueDist_NotAdjusted.pdf", height=15, width=10)
par(mfrow=c(5,2))
for (i in 1:ncol(efit)){
    hist(efit$p.value[,i], main=colnames(efit)[i], ylim=c(0,max(table(round(efit$p.value[,i], 1)))+1000), xlab="p-value")
}
dev.off()

# check p-value distribution for adjusted p-values
pdf("PvalueDist_Adjusted.pdf", height=15, width=10)
par(mfrow=c(5,2))
for (i in 1:ncol(efit)){
    topTable <- topTable(efit, coef=i, n=Inf)
    hist(topTable$adj.P.Val, main=colnames(efit)[i], xlab="p-value")
}
dev.off()

# Verify that control housekeeping genes are not significantly DE. Set up list of housekeeping genes as controls (from Eisenberg and Levanon, 2003)
housekeeping=read.table("/Users/katalinabobowik/Documents/UniMelb_PhD/Analysis/UniMelb_Sumba/BatchEffects/Housekeeping_ControlGenes.txt", as.is=T, header=F)
# if this is broken, use host = "uswest.ensembl.org"
ensembl.mart.90 <- useMart(biomart='ENSEMBL_MART_ENSEMBL', dataset='hsapiens_gene_ensembl', host = 'www.ensembl.org', ensemblRedirect = FALSE)
biomart.results.table <- getBM(attributes = c('ensembl_gene_id', 'external_gene_name'), mart = ensembl.mart.90,values=housekeeping, filters="hgnc_symbol")
hkGenes=as.vector(biomart.results.table[,1])
hkControls=hkGenes[which(hkGenes %in% rownames(y$counts))]

# Volcano plot with points of housekeeping genes
pdf("VolcanoPlots.pdf", height=15, width=10)
par(mfrow=c(5,2))
for (i in 1:ncol(efit)){
    plot(efit$coef[,i], -log10(as.matrix(efit$p.value)[,i]), pch=20, main=colnames(efit)[i], xlab="log2FoldChange", ylab="-log10(pvalue)")
    points(efit$coef[,i][which(names(efit$coef[,i]) %in% hkControls)], -log10(as.matrix(efit$p.value)[,i][which(names(efit$coef[,i]) %in% hkControls)]) , pch=20, col=4, xlab="log2FoldChange", ylab="-log10(pvalue)")
    legend("topleft", "genes", "hk genes",fill=4)
    abline(v=c(-1,1))
}
dev.off()

# PCA visualisation after correction and association with covariates ------------------------------------------------------------

# let's also visualise how our PCAs look after limma correction by using removeBatcheffect. Help on design of removeBatcheffects was given by the lovely John Blischak.
design <- model.matrix(~0 + y$samples$Sampling.Site)
colnames(design)=gsub("Sampling.Site", "", colnames(design))
colnames(design)=gsub("[\\y$]", "", colnames(design))
colnames(design)=gsub("samples", "", colnames(design))

# Remove unused columns from lcpm matrix
lcpm=lcpm[,which(colnames(lcpm) %in% colnames(y))]

batch.corrected.lcpm <- removeBatchEffect(lcpm, batch=y$samples$batch, covariates = cbind(y$samples$Age, y$samples$RIN, y$samples$CD8T, y$samples$CD4T, y$samples$NK, y$samples$Bcell, y$samples$Monoy$samples$Gran),design=design)

# rename column names of lcpm to sample names (so that they are shorter and easier to read)
colnames(lcpm)=sapply(strsplit(colnames(lcpm),"[_.]"), `[`, 1)
# now add a hyphen inbetween the tribe abbreviation and number to keep consistency
colnames(lcpm)[104:107]=sapply(colnames(lcpm)[104:107],function(x)sub("([[:digit:]]{3,3})$", "-\\1", x))

# get which samples are replicates
allreplicated=as.factor(samplenames %in% allreps)

# PCA plotting function
plot.pca <- function(dataToPca, speciesCol, namesPch, sampleNames){
    pca <- prcomp(t(dataToPca), scale=T, center=T)
    pca.var <- pca$sdev^2/sum(pca$sdev^2)
    for (i in 1:9){
        pca_axis1=i
        pca_axis2=i+1
        plot(pca$x[,pca_axis1], pca$x[,pca_axis2], col=speciesCol, pch=namesPch, cex=2, xlab=paste0("PC", pca_axis1, " (", round(pca.var[pca_axis1]*100, digits=2), "% of variance)"), ylab=paste0("PC", pca_axis2, " (", round(pca.var[pca_axis2]*100, digits=2), "% of variance)", sep=""), main=name)
        # points(pca$x[,pca_axis1][which(allreplicated==T)], pca$x[,pca_axis2][which(allreplicated==T)], col="black", pch=8, cex=2)
        # text(pca$x[,pca_axis1][which(allreplicated==T)], pca$x[,pca_axis2][which(allreplicated==T)], labels=samplenames[which(allreplicated==T)], pos=3)
        legend(legend=unique(sampleNames), pch=16, x="bottomright", col=unique(speciesCol), cex=0.6, title=name, border=F, bty="n")
        legend(legend=unique(as.numeric(y$samples$batch)), "topright", pch=unique(as.numeric(y$samples$batch)) + 14, title="Batch", cex=0.6, border=F, bty="n")
    }

    return(pca)
}

# PCA association function
pc.assoc <- function(pca.data){
    all.pcs <- data.frame()
    for (i in 1:ncol(pca.data$x)){
        all.assoc <- vector()
        for (j in 1:ncol(all.covars.df)){
            test.assoc <- anova(lm(pca.data$x[,i] ~ all.covars.df[,j]))[1,5]
            all.assoc <- c(all.assoc, test.assoc)
        }
        single.pc <- c(i, all.assoc)
        all.pcs <- rbind(all.pcs, single.pc)
    }
    names(all.pcs) <- c("PC", colnames(all.covars.df))

    print ("Here are the relationships between PCs and some possible covariates")
    print (all.pcs)
    return (all.pcs)
}

# Prepare covariate matrix
all.covars.df <- y$samples[,c(3,5:22)] 

# Plot PCA
for (name in covariate.names[c(1:10,17:18)]){
  if (nlevels(get(name)) < 26){
    pdf(paste0("batchCorrected_pcaresults_",name,".pdf"))
    pcaresults <- plot.pca(dataToPca=batch.corrected.lcpm, speciesCol=as.numeric(get(name)),namesPch=as.numeric(y$samples$batch) + 14,sampleNames=get(name))
    dev.off()
  } else {
    pdf(paste0("pcaresults_",name,".pdf"))
    pcaresults <- plot.pca(dataToPca=batch.corrected.lcpm, speciesCol=as.numeric(get(name)),namesPch=20,sampleNames=get(name))
    dev.off()
  }
}

# plot batch (this has to be done separately since it ha sa different colour scheme)
pdf(paste0("batchCorrected_pcaresults_batch.pdf"))
name="batch"
pcaresults <- plot.pca(dataToPca=batch.corrected.lcpm, speciesCol=batch.col[as.numeric(batch)],namesPch=as.numeric(y$samples$batch) + 14,sampleNames=batch)
dev.off()
  
# plot blood - this one also has a differnet gradient colour scheme
for (name in covariate.names[c(11:16)]){
    initial <- cut(get(name), breaks = seq(min(get(name), na.rm=T), max(get(name), na.rm=T), len = 80),include.lowest = TRUE)
    bloodCol <- colorRampPalette(c("blue", "red"))(79)[initial]
    pdf(paste0("batchCorrected_pcaresults_",name,".pdf"))
    pcaresults <- plot.pca(dataToPca=batch.corrected.lcpm, speciesCol=bloodCol,namesPch=as.numeric(y$samples$batch) + 14,sampleNames=get(name))
    dev.off()
}

# Get PCA associations
all.pcs <- pc.assoc(pcaresults)
all.pcs$Variance <- pcaresults$sdev^2/sum(pcaresults$sdev^2)

# plot pca covariates association matrix to illustrate any remaining confounding/batch
pdf("significantCovariates_AnovaHeatmap.pdf")
pheatmap(all.pcs[1:5,c(3:20)], cluster_col=F, col= colorRampPalette(brewer.pal(11, "RdYlBu"))(100), cluster_rows=F, main="Significant Covariates \n Anova")
dev.off()

# Write out the covariates:
write.table(all.pcs, file="pca_covariates_blood.txt", col.names=T, row.names=F, quote=F, sep="\t")

# Summary and visualisation of gene trends ---------------------------------------------------------------------------

# first see which logFC threshold is best
logFC.df=matrix(nrow=3,ncol=ncol(efit))
colnames(logFC.df)=colnames(efit)
counter=0
for (number in c(0,0.5,1)){
    counter=counter+1
    dt <- decideTests(efit, p.value=0.01, lfc=number)
    values=summary(abs(dt))[3,]
    logFC.df[counter,]=values
}
# add in column specifying logFC
logFC.df=cbind(logFC = c(0,0.5,1), logFC.df)
write.table(logFC.df, file="logFC_thresholds.txt", sep="\t", quote=F)

dt <- decideTests(efit, p.value=0.01, lfc=1)
# get summary of decide tests statistics
write.table(summary(dt), file="numberSigDEgenes_voom_efit.txt")
# write out top table results 
write.fit(efit, dt, file="toptable_SigGenes_voom_efit.txt")

# graphical representation of DE results through MD plot
pdf("MD_Plots_pval01_lfc1.pdf", height=15, width=10)
par(mfrow=c(5,2))
for (i in 1:ncol(efit)){
    o <- which(names(efit$Amean) %in% names(which(abs(dt[,i])==1)))
    x <- efit$Amean
    z <- efit$coefficients[,i]
    t=which(names(efit$coefficients[,i]) %in% names(which(abs(dt[,i])==1)))
    G <- efit$genes[names(which(abs(dt[,i])==1)),]$SYMBOL
    plotMD(efit, column=i, status=dt[,i], main=colnames(efit)[i], hl.col=c("blue","red"), values=c(-1,1))
    abline(h=c(1,-1), lty=2)
    legend(legend=paste(names(summary(dt)[,i]), summary(dt)[,i], sep="="), x="bottomright", border=F, bty="n")
    if(length(o)>0){
        text(x[o], z[t], labels=G)
    }
}
dev.off()

# plot log2 fold change between villages
pdf("log2FC_IslandComparisons_pval01.pdf")
# note 'p.value' is the cutoff value for adjusted p-values
newcol=brewer.pal(n=12,"Paired")
topTable <- topTable(efit, coef=1, n=Inf, p.value=0.01)
plot(density(topTable$logFC), col=newcol[1], xlim=c(-2,2), main="LogFC Density", xlab="LogFC", ylab="Density", lwd=6)
abline(v=c(-1,-0.5,0.5,1), lty=3)
counter=1
for (i in 2:ncol(efit)){
	counter=counter+1
    topTable <- topTable(efit, coef=i, n=Inf, p.value=0.01)
    lines(density(topTable$logFC), col=newcol[counter], xlim=c(-2,2), lwd=6)
}
legend(x="topright", bty="n", col=newcol[1:ncol(efit)], legend=colnames(efit), lty=1, lwd=6)
dev.off()

# We can also look at the top ten DE genes with a heatmap of logCPM values for the top 100 genes. Each gene (or row) is scaled so that mean expression is zero and the standard deviation is one (we're using 'E' from the voom object which is a numeric matrix of normalized expression values on the log2 scale). Samples with relatively high expression of a given gene are marked in red and samples with relatively low expression are marked in blue. Lighter shades and white represent genes with intermediate expression levels. Samples and genes are reordered by the method of hierarchical clustering
# first, make a heatmap of all top genes in one pdf

# reset ensemble row names to gene symbols
rownames(v$E)=v$genes$SYMBOL

# set up annotation
col_fun = colorRamp2(c(-4, 0, 4), c("blue", "white", "red"))

df1=data.frame(village = as.character(y$samples$Sampling.Site))
df2=data.frame(batch = as.numeric(batch))
ha1 = HeatmapAnnotation(df = df1, col = list(village = c("Anakalung" =  1, "Madobag" = 2, "Mappi" = 3, "Taileleu"=4, "Wunga"=5)))

for (i in 1:ncol(efit)){
    topTable <- topTable(efit, coef=i, p.value=0.01, lfc=1, n=Inf, sort.by="p")
    index <- which(v$genes$ENSEMBL %in% topTable$ENSEMBL[1:10])
    pdf(paste0("Heatmap_",colnames(efit)[i],".pdf"), height=15, width=15)
    draw(Heatmap(t(scale(t(v$E[index,]))), col=col_fun, column_title = colnames(efit)[i], top_annotation = ha1, show_row_names = T, show_heatmap_legend = F, show_column_names = F, name = "Z-Score"),show_annotation_legend = FALSE,newpage=F)
    dev.off()
}

# We can also make individual pdfs of the top genes
village1=c("Anakalung","Madobag","Mappi","Taileleu","Wunga")
village2=c("Anakalung","Madobag","Mappi","Taileleu","Wunga")

counter=0
for (i1 in village1){
    village2=village2[-1]
    for (i2 in village2){
        counter=counter+1
        topTable <- topTable(efit, coef=counter, p.value=0.01, lfc=1, n=Inf, sort.by="p")
        index <- which(v$genes$ENSEMBL %in% topTable$ENSEMBL[1:10])
        df=data.frame(village = as.character(y$samples$Sampling.Site[grep(paste(i1,i2,sep="|"), y$samples$Sampling.Site)]))
        ha =  HeatmapAnnotation(df = df, col = list(village = c("Anakalung" =  1, "Madobag" = 2, "Mappi" = 3, "Taileleu"=4, "Wunga" = 5)))
        pdf(paste("HeatmapTopGenes",i1,i2,".pdf",sep="_"), height=10, width=15)
        draw(Heatmap(t(scale(t(v$E[index,])))[,grep(paste(i1,i2,sep="|"), y$samples$Sampling.Site)], col=col_fun, column_title = colnames(efit)[counter], top_annotation = ha, show_row_names = T, show_heatmap_legend = T, show_column_names = T, name = "Z-Score"),show_annotation_legend = TRUE,newpage=F)
        dev.off()
    }
}

# Look at which genes are in common using UpsetR
pdf("UpsetR_SamplingSiteComparison.pdf")
upset(as.data.frame(abs(dt)), sets = c("ANKvsMDB" ,"ANKvsMPI", "ANKvsTLL", "ANKvsWNG", "MDBvsMPI", "MDBvsTLL", "MDBvsWNG", "MPIvsTLL", "MPIvsWNG", "TLLvsWNG"), sets.bar.color = "#56B4E9", nintersects=100, keep.order=TRUE)
dev.off()


# Check which genes are shared within villages -----------------------------------------------------------------------------------------

# Sumba villages=ANK and WNG; Mentawai villages= TLL and MDB. MDB vs TLL= 0 significant genes. ANK vs WNG = 2 significant genes. Which ones are these?

topTable <- topTable(efit, coef=4, p.value=0.01, lfc=1, n=Inf, sort.by="p")
rownames(topTable)
# "ENSG00000251002" "ENSG00000131203"
# ENSG00000251002 doesn't have a gene name associated with it, but according to Genecards, "it is an RNA Gene". That's about as much information as I could get...
# The other significant gene is ENSG00000131203, which is equivalent to IDO1. According to Genecards, "IDO1 (Indoleamine 2,3-Dioxygenase 1) is a Protein Coding gene. Diseases associated with IDO1 include Chlamydia and Listeriosis. Among its related pathways are Histidine, lysine, phenylalanine, tyrosine, proline and tryptophan catabolism and NF-kappaB Signaling. Gene Ontology (GO) annotations related to this gene include heme binding and tryptophan 2,3-dioxygenase activity."




