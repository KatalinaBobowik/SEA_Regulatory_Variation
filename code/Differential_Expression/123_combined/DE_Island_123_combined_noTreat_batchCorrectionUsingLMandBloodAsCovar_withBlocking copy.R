# script created by KSB, 08.08.18
# Perform DE analysing relationship between islands

### Last edit: KB 03.04.2019

# Load dependencies and set input paths --------------------------

# Load dependencies:
library(edgeR)
library(plyr)
library(NineteenEightyR)
library(RColorBrewer)
library(biomaRt)
library(ggpubr)
library(ggplot2)
library(ggsignif)
library(pheatmap)
library(viridis)
library(gplots)
library(circlize)
library(ComplexHeatmap)
library(EnsDb.Hsapiens.v86)
library(statmod)

# Set paths:
inputdir = "/Users/katalinabobowik/Documents/UniMelb_PhD/Analysis/UniMelb_Sumba/Output/DE_Analysis/123_combined/dataPreprocessing/"
housekeepingdir="/Users/katalinabobowik/Documents/UniMelb_PhD/Analysis/UniMelb_Sumba/BatchEffects/"

# Set output directory and create it if it does not exist:
outputdir <- "/Users/katalinabobowik/Documents/UniMelb_PhD/Analysis/UniMelb_Sumba/Output/DE_Analysis/123_combined/DE_Island/LM_allCovarPlusBlood/"

if (file.exists(outputdir) == FALSE){
    dir.create(outputdir)
}

# Load colour schemes:
wes=c("#3B9AB2", "#EBCC2A", "#F21A00", "#00A08A", "#ABDDDE", "#000000", "#FD6467","#5B1A18")
palette(c(wes, brewer.pal(8,"Dark2")))
# set up colour palette for batch
batch.col=electronic_night(n=3)
village.col=c("#EBCC2A","chocolate","chocolate","#3B9AB2","#F21A00","chocolate","chocolate","chocolate","#78B7C5","orange","chocolate")
dev.off()

# BEGIN ANALYSIS -------------------------------------------------------------------------------------------------

# Load log CPM matrix and y object:
# lcpm
load(paste0(inputdir, "indoRNA.logCPM.TMM.filtered.Rda"))
# y DGE list object
load(paste0(inputdir, "indoRNA.read_counts.TMM.filtered.Rda"))

# Initial QC -----------------------------------------------------------------------

# We don't know what the age is for SMB-PTB028 (#116) so we will just add in the median age of Sumba (44.5)
y$samples$Age[which(is.na(y$samples$Age) == T)]=45

# Set up design matrix
design <- model.matrix(~0 + y$samples$Island + y$samples$Age + y$samples$batch + y$samples$RIN + y$samples$CD8T + y$samples$CD4T + y$samples$NK + y$samples$Bcell + y$samples$Mono + y$samples$Gran)
colnames(design)=gsub("Island", "", colnames(design))

# rename columns to exclude spaces and unrecognised characters
colnames(design)=gsub("[\\y$]", "", colnames(design))
colnames(design)=gsub("samples", "", colnames(design))
colnames(design)=gsub("West Papua", "Mappi", colnames(design))

# set up contrast matrix
contr.matrix <- makeContrasts(SMBvsMTW=Sumba - Mentawai, SMBvsMPI=Sumba - Mappi, MTWvsMPI=Mentawai - Mappi, levels=colnames(design))

# plot mean-variance trend for different normalisation methods. This is helpfule for understandimg what should be done with estimating the dispersion: https://support.bioconductor.org/p/77664/
pdf(paste0(outputdir, "EstimatingDispersion_allNormalisationMethods.pdf"), height=15, width=15)
par(mfrow=c(4,3))
# first perform voom on unnormalised data
y$samples$norm.factors <- 1
estimateDisp <- estimateDisp(y, design, robust=TRUE)
plotBCV(estimateDisp)
title(paste0("None","\nDispersion Range = ",round(min(estimateDisp$prior.df), 2), "-", round(max(estimateDisp$prior.df), 2)))
v <- voom(y, design, plot=TRUE)
title(main="None", line=0.5)
# fit linear models
vfit <- lmFit(v, design)
vfit <- contrasts.fit(vfit, contrasts=contr.matrix)
efit <- eBayes(vfit, robust=T)
plotSA(efit, main="Mean-variance trend elimination \n None")

# now perform normalisation on all the others
for (method in c("upperquartile", "TMM", "RLE")) {
    y <- calcNormFactors(y, method=method)
    estimateDisp <- estimateDisp(y, design, robust=TRUE)
    plotBCV(estimateDisp)
    title(paste0(method,"\nDispersion Range = ",round(min(estimateDisp$prior.df), 2), "-", round(max(estimateDisp$prior.df), 2)))
    v <- voom(y, design, plot=TRUE)
    title(main=method, line=0.5)
    # fit linear models
    vfit <- lmFit(v, design)
    vfit <- contrasts.fit(vfit, contrasts=contr.matrix)
    efit <- eBayes(vfit, robust=T)
    plotSA(efit, main=paste("Mean-variance trend elimination",method,sep="\n"))
}
dev.off()

# we'll go ahead an stick with TMM normalisation
y <- calcNormFactors(y, method="TMM")

# We can view how TMM normalisation performed using MD plots. This visualizes the library size-adjusted log-fold change between
# two libraries (the difference) against the average log-expression across those libraries (themean). MD plots are generated by comparing sample 1 against an artificial
# library constructed from the average of all other samples. Ideally, the bulk of genes should be centred at a log-fold change of zero.  This indicates
# that any composition bias between libraries has been successfully removed
pdf(paste0(outputdir,"MDPlots_TMM_Normalisation_OutliersCheck.pdf"), height=15, width=15)
par(mfrow=c(4,4))
for (i in 1:ncol(y)){
  plotMD(cpm(y, log=TRUE), column=i)
  abline(h=0, col="red", lty=2, lwd=2)
}
dev.off()

# Using duplicate correlation and blocking -----------------------------------------------------

# First, we need to perform voom normalisation
v <- voom(y, design, plot=F)

# create a new variable for blocking using sample IDs
# define sample names
samplenames <- as.character(y$samples$samples)
samplenames <- sub("([A-Z]{3})([0-9]{3})", "\\1-\\2", samplenames)
samplenames <- sapply(strsplit(samplenames, "[_.]"), `[`, 1)

y$samples$ind <- samplenames

# Estimate the correlation between the replicates.
# Information is borrowed by constraining the within-block corre-lations to be equal between genes and by using empirical Bayes methods to moderate the standarddeviations between genes 
dupcor <- duplicateCorrelation(v, design, block=y$samples$ind)
# The value dupcor$consensus estimates the average correlation within the blocks and should be positive
dupcor$consensus # sanity check
# [1] 0.6796663
median(v$weights) # another sanity check:
# [1]  22.8338

# run voom a second time with the blocking variable and estimated correlation
# The  vector y$samples$ind indicates the  two  blocks  corresponding  to  biological  replicates
pdf(paste0(outputdir,"Limma_voomDuplicateCorrelation_TMMNormalisation.pdf"), height=8, width=12)
par(mfrow=c(1,2))
vDup <- voom(y, design, plot=TRUE, block=y$samples$ind, correlation=dupcor$consensus)
dupcor <- duplicateCorrelation(vDup, design, block=y$samples$ind) # get warning message: Too much damping - convergence tolerance not achievable
dupcor$consensus # sanity check pt 2
# [1]  0.6796721
median(vDup$weights) # another sanity check, pt 2 
# [1] 22.41583

# With duplicate correction and blocking:
# the inter-subject correlation is input into the linear model fit
voomDupVfit <- lmFit(vDup, design, block=y$samples$ind, correlation=dupcor$consensus)
voomDupVfit <- contrasts.fit(voomDupVfit, contrasts=contr.matrix)
voomDupEfit <- eBayes(voomDupVfit, robust=T)

plotSA(voomDupEfit, main="Mean-variance trend elimination with duplicate correction")
dev.off()

# save voom and efit object
save(vDup, file = paste0(outputdir, "vDup.Rda"))
save(voomDupEfit, file = paste0(outputdir, "voomDupEfit.Rda"))

# get top genes using toptable
voomDupTopTableSMB.MTW <- topTable(voomDupEfit, coef=1, p.value=0.01, n=Inf, sort.by="p")
write.table(voomDupTopTableSMB.MTW , file=paste0(outputdir,"topTable_SMBvsMTW.txt"))
voomDupTopTableSMB.MPI <- topTable(voomDupEfit, coef=2, p.value=0.01, n=Inf, sort.by="p")
write.table(voomDupTopTableSMB.MPI , file=paste0(outputdir,"topTable_SMBvsMPI.txt"))
voomDupTopTableMTW.MPI <- topTable(voomDupEfit, coef=3, p.value=0.01, n=Inf, sort.by="p")
write.table(voomDupTopTableMTW.MPI , file=paste0(outputdir,"topTable_MTWvsMPI.txt"))

# get number of DE genes at differnet thresholds
# noLFC
summary(decideTests(voomDupEfit, method="separate", adjust.method = "BH", p.value = 0.01))
#       SMBvsMTW SMBvsMPI MTWvsMPI
#Down        898     2325     2102
#NotSig    11430     8479     8887
#Up          647     2171     1986
write.table(decideTests(voomDupEfit, method="separate", adjust.method = "BH", p.value = 0.01), file=paste0(outputdir,"numberDEgens_adjustmethodBH_noLFC_pval01.txt"))

# LFC of 0.5
summary(decideTests(voomDupEfit, method="separate", adjust.method = "BH", p.value = 0.01, lfc=0.5))
#       SMBvsMTW SMBvsMPI MTWvsMPI
#Down         96      606      536
#NotSig    12661    11577    11958
#Up          218      792      481
write.table(decideTests(voomDupEfit,method="separate", adjust.method = "BH", p.value = 0.01, lfc=0.5), file=paste0(outputdir,"numberDEgens_adjustmethodBH_LFC05_pval01.txt"))

# LFC of 1
summary(decideTests(voomDupEfit, method="separate", adjust.method = "BH", p.value = 0.01, lfc=1))
#       SMBvsMTW SMBvsMPI MTWvsMPI
#Down          6       87       96
#NotSig    12940    12662    12748
#Up           29      226      131
write.table(decideTests(voomDupEfit,method="separate", adjust.method = "BH", p.value = 0.01, lfc=1), file=paste0(outputdir,"numberDEgens_adjustmethodBH_LFC1_pval01.txt"))


# with scaled values -------------------------------------------------

# read in scaled deconvalues
deconDir = "/Users/katalinabobowik/Documents/UniMelb_PhD/Analysis/UniMelb_Sumba/Output/DE_Analysis/123_combined/batchRemoval/"
deconCell = read.table(paste0(deconDir, "predictedCellCounts_DeconCell_Paper.txt"))

# are the sample names identical?
identical(rownames(y$samples), rownames(y$samples))
# TRUE

# make rownames the same in deconCell file
colnames(deconCell)=colnames(y$samples[,c(16:21)])

# replace values of non-scaled blood proportion estimates with scaled values
y$samples[,c(16:21)] = deconCell
# y$samples[,c(16:21)] = log(y$samples[,c(16:21)])

rowSums(y$samples[,c(16:21)])
# 100

# run voom and same pipeline again
v <- voom(y, design, plot=F)
dupcor <- duplicateCorrelation(v, design, block=y$samples$ind)
dupcor$consensus # sanity check
# [1] 0.6796663
median(v$weights) # another sanity check:
# 22.8338

# run once more 
vDup.scaled <- voom(y, design, plot=TRUE, block=y$samples$ind, correlation=dupcor$consensus)
dupcor.scaled <- duplicateCorrelation(vDup.scaled, design, block=y$samples$ind) # get warning message: Too much damping - convergence tolerance not achievable
dupcor.scaled$consensus # sanity check pt 2
# [1]  0.6796721
median(vDup$weights) # another sanity check, pt 2 
# 22.41583

# With duplicate correction and blocking:
# the inter-subject correlation is input into the linear model fit
voomDupVfit.scaled <- lmFit(vDup.scaled, design, block=y$samples$ind, correlation=dupcor.scaled$consensus)
voomDupVfit.scaled <- contrasts.fit(voomDupVfit.scaled, contrasts=contr.matrix)
voomDupEfit.scaled <- eBayes(voomDupVfit.scaled, robust=T)

# get top genes using toptable
voomDupTopTableSMB.MTW <- topTable(voomDupEfit, coef=1, p.value=0.01, n=Inf, sort.by="p")
voomDupTopTableSMB.MPI <- topTable(voomDupEfit, coef=2, p.value=0.01, n=Inf, sort.by="p")
voomDupTopTableMTW.MPI <- topTable(voomDupEfit, coef=3, p.value=0.01, n=Inf, sort.by="p")

# get number of DE genes at differnet thresholds
# noLFC
summary(decideTests(voomDupEfit.scaled, method="separate", adjust.method = "BH", p.value = 0.01))
#       SMBvsMTW SMBvsMPI MTWvsMPI
#Down        898     2325     2102
#NotSig    11430     8479     8887
#Up          647     2171     1986

# LFC of 0.5
summary(decideTests(voomDupEfit.scaled, method="separate", adjust.method = "BH", p.value = 0.01, lfc=0.5))
#       SMBvsMTW SMBvsMPI MTWvsMPI
#Down         96      606      536
#NotSig    12661    11577    11958
#Up          218      792      481

# LFC of 1
summary(decideTests(voomDupEfit.scaled, method="separate", adjust.method = "BH", p.value = 0.01, lfc=1))
#       SMBvsMTW SMBvsMPI MTWvsMPI
#Down          6       87       96
#NotSig    12940    12662    12748
#Up           29      226      131

venn()

