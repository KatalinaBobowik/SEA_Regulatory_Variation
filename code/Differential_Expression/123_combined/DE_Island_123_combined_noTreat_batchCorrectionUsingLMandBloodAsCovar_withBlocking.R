# script created by KSB, 08.08.18
# Perform DE analysing relationship between islands

### Last edit: KB 03.04.2019

# Load dependencies and set input paths --------------------------

# Load dependencies:
library(edgeR)
library(plyr)
library(NineteenEightyR)
library(RColorBrewer)
library(biomaRt)
library(ggpubr)
library(ggplot2)
library(ggsignif)
library(pheatmap)
library(viridis)
library(gplots)
library(circlize)
library(ComplexHeatmap)
library(EnsDb.Hsapiens.v86)

# Set paths:
inputdir = "/Users/katalinabobowik/Documents/UniMelb_PhD/Analysis/UniMelb_Sumba/Output/DE_Analysis/123_combined/dataPreprocessing/"
housekeepingdir="/Users/katalinabobowik/Documents/UniMelb_PhD/Analysis/UniMelb_Sumba/BatchEffects/"

# Set output directory and create it if it does not exist:
outputdir <- "/Users/katalinabobowik/Documents/UniMelb_PhD/Analysis/UniMelb_Sumba/Output/DE_Analysis/123_combined/DE_Island/LM_allCovarPlusBlood/"

if (file.exists(outputdir) == FALSE){
    dir.create(outputdir)
}

# Load colour schemes:
wes=c("#3B9AB2", "#EBCC2A", "#F21A00", "#00A08A", "#ABDDDE", "#000000", "#FD6467","#5B1A18")
palette(c(wes, brewer.pal(8,"Dark2")))
# set up colour palette for batch
batch.col=electronic_night(n=3)
dev.off()

# BEGIN ANALYSIS -------------------------------------------------------------------------------------------------

# Load log CPM matrix and y object:
# lcpm
load(paste0(inputdir, "indoRNA.logCPM.TMM.filtered.Rda"))
# y DGE list object
load(paste0(inputdir, "indoRNA.read_counts.TMM.filtered.Rda"))

# Initial QC -----------------------------------------------------------------------

# We don't know what the age is for SMB-PTB028 (#116) so we will just add in the median age of Sumba (44.5)
y$samples$Age[which(is.na(y$samples$Age) == T)]=45

# Set up design matrix
design <- model.matrix(~0 + y$samples$Island + y$samples$Age + y$samples$batch + y$samples$RIN + y$samples$CD8T + y$samples$CD4T + y$samples$NK + y$samples$Bcell + y$samples$Mono + y$samples$Gran)
colnames(design)=gsub("Island", "", colnames(design))

# rename columns to exclude spaces and unrecognised characters
colnames(design)=gsub("[\\y$]", "", colnames(design))
colnames(design)=gsub("samples", "", colnames(design))
colnames(design)=gsub("West Papua", "Mappi", colnames(design))

# set up contrast matrix
contr.matrix <- makeContrasts(SMBvsMTW=Sumba - Mentawai, SMBvsMPI=Sumba - Mappi, MTWvsMPI=Mentawai - Mappi, levels=colnames(design))

# plot mean-variance trend for different normalisation methods. This is helpfule for understandimg what should be done with estimating the dispersion: https://support.bioconductor.org/p/77664/
pdf(paste0(outputdir, "EstimatingDispersion_allNormalisationMethods.pdf"), height=15, width=15)
par(mfrow=c(4,3))
# first perform voom on unnormalised data
y$samples$norm.factors <- 1
estimateDisp <- estimateDisp(y, design, robust=TRUE)
plotBCV(estimateDisp)
title(paste0("None","\nDispersion Range = ",round(min(estimateDisp$prior.df), 2), "-", round(max(estimateDisp$prior.df), 2)))
v <- voom(y, design, plot=TRUE)
title(main="None", line=0.5)
# fit linear models
vfit <- lmFit(v, design)
vfit <- contrasts.fit(vfit, contrasts=contr.matrix)
efit <- eBayes(vfit, robust=T)
plotSA(efit, main="Mean-variance trend elimination \n None")

# now perform normalisation on all the others
for (method in c("upperquartile", "TMM", "RLE")) {
    y <- calcNormFactors(y, method=method)
    estimateDisp <- estimateDisp(y, design, robust=TRUE)
    plotBCV(estimateDisp)
    title(paste0(method,"\nDispersion Range = ",round(min(estimateDisp$prior.df), 2), "-", round(max(estimateDisp$prior.df), 2)))
    v <- voom(y, design, plot=TRUE)
    title(main=method, line=0.5)
    # fit linear models
    vfit <- lmFit(v, design)
    vfit <- contrasts.fit(vfit, contrasts=contr.matrix)
    efit <- eBayes(vfit, robust=T)
    plotSA(efit, main=paste("Mean-variance trend elimination",method,sep="\n"))
}
dev.off()

# we'll go ahead an stick with TMM normalisation
y <- calcNormFactors(y, method="TMM")

# We can view how TMM normalisation performed using MD plots. This visualizes the library size-adjusted log-fold change between
# two libraries (the difference) against the average log-expression across those libraries (themean). MD plots are generated by comparing sample 1 against an artificial
# library constructed from the average of all other samples. Ideally, the bulk of genes should be centred at a log-fold change of zero.  This indicates
# that any composition bias between libraries has been successfully removed
pdf(paste0(outputdir,"MDPlots_TMM_Normalisation_OutliersCheck.pdf"), height=15, width=15)
par(mfrow=c(4,4))
for (i in 1:ncol(y)){
  plotMD(cpm(y, log=TRUE), column=i)
  abline(h=0, col="red", lty=2, lwd=2)
}
dev.off()

# Using duplicate correlation and blocking -----------------------------------------------------

# First, we need to perform voom normalisation
v <- voom(y, design, plot=F)

# create a new variable for blocking using sample IDs
# define sample names
samplenames <- as.character(y$samples$samples)
samplenames <- sub("([A-Z]{3})([0-9]{3})", "\\1-\\2", samplenames)
samplenames <- sapply(strsplit(samplenames, "[_.]"), `[`, 1)

y$samples$ind <- samplenames

# Estimate the correlation between the replicates.
# Information is borrowed by constraining the within-block corre-lations to be equal between genes and by using empirical Bayes methods to moderate the standarddeviations between genes 
dupcor <- duplicateCorrelation(v, design, block=y$samples$ind)
# The value dupcor$consensus estimates the average correlation within the blocks and should be positive
dupcor$consensus # sanity check
# [1] 0.6796663
median(v$weights) # another sanity check:
# [1]  22.8338

# run voom a second time with the blocking variable and estimated correlation
# The  vector y$samples$ind indicates the  two  blocks  corresponding  to  biological  replicates
pdf(paste0(outputdir,"Limma_voomDuplicateCorrelation_TMMNormalisation.pdf"), height=8, width=12)
par(mfrow=c(1,2))
vDup <- voom(y, design, plot=TRUE, block=y$samples$ind, correlation=dupcor$consensus)
dupcor <- duplicateCorrelation(vDup, design, block=y$samples$ind) # get warning message: Too much damping - convergence tolerance not achievable
dupcor$consensus # sanity check pt 2
# [1]  0.6796721
median(vDup$weights) # another sanity check, pt 2 
# [1] 22.41583

# With duplicate correction and blocking:
# the inter-subject correlation is input into the linear model fit
voomDupVfit <- lmFit(vDup, design, block=y$samples$ind, correlation=dupcor$consensus)
voomDupVfit <- contrasts.fit(voomDupVfit, contrasts=contr.matrix)
voomDupEfit <- eBayes(voomDupVfit, robust=T)

plotSA(voomDupEfit, main="Mean-variance trend elimination with duplicate correction")
dev.off()

# save voom and efit object
save(vDup, file = paste0(outputdir, "vDup.Rda"))
save(voomDupEfit, file = paste0(outputdir, "voomDupEfit.Rda"))

# get top genes using toptable
voomDupTopTableSMB.MTW <- topTable(voomDupEfit, coef=1, p.value=0.01, n=Inf, sort.by="p")
voomDupTopTableSMB.MPI <- topTable(voomDupEfit, coef=2, p.value=0.01, n=Inf, sort.by="p")
voomDupTopTableMTW.MPI <- topTable(voomDupEfit, coef=3, p.value=0.01, n=Inf, sort.by="p")

# get number of DE genes at differnet thresholds
# noLFC
summary(decideTests(voomDupEfit, method="separate", adjust.method = "BH", p.value = 0.01))
#       SMBvsMTW SMBvsMPI MTWvsMPI
#Down        898     2325     2102
#NotSig    11430     8479     8887
#Up          647     2171     1986
write.table(decideTests(voomDupEfit, method="separate", adjust.method = "BH", p.value = 0.01), file=paste0(outputdir,"numberDEgens_adjustmethodBH_noLFC_pval01.txt"))

# LFC of 0.5
summary(decideTests(voomDupEfit, method="separate", adjust.method = "BH", p.value = 0.01, lfc=0.5))
#       SMBvsMTW SMBvsMPI MTWvsMPI
#Down         96      606      536
#NotSig    12661    11577    11958
#Up          218      792      481
write.table(decideTests(voomDupEfit,method="separate", adjust.method = "BH", p.value = 0.01, lfc=0.5), file=paste0(outputdir,"numberDEgens_adjustmethodBH_LFC05_pval01.txt"))

# LFC of 1
summary(decideTests(voomDupEfit, method="separate", adjust.method = "BH", p.value = 0.01, lfc=1))
#       SMBvsMTW SMBvsMPI MTWvsMPI
#Down          6       87       96
#NotSig    12940    12662    12748
#Up           29      226      131
write.table(decideTests(voomDupEfit,method="separate", adjust.method = "BH", p.value = 0.01, lfc=1), file=paste0(outputdir,"numberDEgens_adjustmethodBH_LFC1_pval01.txt"))


# Without duplicate correlation -------------------------------------------------

pdf(paste0(outputdir,"Limma_voom_TMMNormalisation.pdf"), height=8, width=12)
vfit <- lmFit(v, design)
vfit <- contrasts.fit(vfit, contrasts=contr.matrix)
efit <- eBayes(vfit, robust=T)

plotSA(efit, main="Mean-variance trend elimination without duplicate correction")
dev.off()

# get top genes using toptable
topTableSMB.MTW <- topTable(efit, coef=1, p.value=0.01, n=Inf, sort.by="p")
topTableSMB.MPI <- topTable(efit, coef=2, p.value=0.01, n=Inf, sort.by="p")
topTableMTW.MPI <- topTable(efit, coef=3, p.value=0.01, n=Inf, sort.by="p")

# no LFC threshold
summary(decideTests(efit, method="separate", adjust.method = "BH", p.value = 0.01))
#       SMBvsMTW SMBvsMPI MTWvsMPI
#Down       1032     2569     2228
#NotSig    11183     8106     8669
#Up          760     2300     2078
write.table(summary(decideTests(efit, method="separate", adjust.method = "BH", p.value = 0.01)), file=paste0(outputdir,"numberDEgens_adjustmethodBH_noLFC_pval01_noDupCor.txt"))

# LFC of 0.05
summary(decideTests(efit, method="separate", adjust.method = "BH", p.value = 0.01, lfc=0.5))
#       SMBvsMTW SMBvsMPI MTWvsMPI
#Down        112      654      558
#NotSig    12603    11492    11920
#Up          260      829      497
write.table(summary(decideTests(efit, method="separate", adjust.method = "BH", p.value = 0.01, lfc=0.5)), file=paste0(outputdir,"numberDEgens_adjustmethodBH_LFC05_pval01_noDupCor.txt"))

# LFC of 1
summary(decideTests(efit, method="separate", adjust.method = "BH", p.value = 0.01, lfc=1))
#       SMBvsMTW SMBvsMPI MTWvsMPI
#Down          6       93      103
#NotSig    12923    12643    12737
#Up           46      239      135
write.table(summary(decideTests(efit, method="separate", adjust.method = "BH", p.value = 0.01, lfc=1)), file=paste0(outputdir,"numberDEgens_adjustmethodBH_LFC1_pval01_noDupCor.txt"))

# Let's check the correlation between those two measurements - sort by gene first, then cor test on adjusted p-value
MTW.MPI <- join(voomDupTopTableMTW.MPI, topTableMTW.MPI, by="ENSEMBL")
cor(MTW.MPI[,8], MTW.MPI[,16], method="spearman", use="complete")
# 0.96594

SMB.MPI <- join(voomDupTopTableSMB.MPI, topTableSMB.MPI, by="ENSEMBL")
cor(SMB.MPI[,8], SMB.MPI[,16], method="spearman", use="complete")
# 0.9430708

SMB.MTW <- join(voomDupTopTableSMB.MTW, topTableSMB.MTW, by="ENSEMBL")
cor(SMB.MTW[,8], SMB.MTW[,16], method="spearman", use="complete")
# 0.8951765

# Visual QC of duplicate correlation voom output after fitting linear models --------------------------------------------------------------------------------------

# check to see p-value distribution is normal
pdf(paste0(outputdir,"PvalueDist_NotAdjusted_dupCor.pdf"), height=15, width=10)
par(mfrow=c(3,1))
for (i in 1:ncol(efit)){
    hist(voomDupEfit$p.value[,i], main=colnames(voomDupEfit)[i], ylim=c(0,max(table(round(voomDupEfit$p.value[,i], 1)))+1000), xlab="p-value")
}
dev.off()

# check p-value distribution for adjusted p-values
pdf(paste0(outputdir,"PvalueDist_Adjusted_dupCor.pdf"), height=15, width=10)
par(mfrow=c(3,1))
for (i in 1:ncol(voomDupEfit)){
    topTable <- topTable(voomDupEfit, coef=i, n=Inf)
    histData <- hist(topTable$adj.P.Val, main=colnames(voomDupEfit)[i], xlab="p-value")
    hist(topTable$adj.P.Val, main=colnames(voomDupEfit)[i], ylim=c(0,max(histData$counts)+1000), xlab="p-value")
}
dev.off()

# Verify that control housekeeping genes are not significantly DE. Set up list of housekeeping genes as controls (from Eisenberg and Levanon, 2003)
housekeeping=read.table(paste0(housekeepingdir,"Housekeeping_ControlGenes.txt"), as.is=T, header=F)
# if this is broken, use host = "uswest.ensembl.org"
ensembl.mart.90 <- useMart(biomart='ENSEMBL_MART_ENSEMBL', dataset='hsapiens_gene_ensembl', host = 'www.ensembl.org', ensemblRedirect = FALSE)
biomart.results.table <- getBM(attributes = c('ensembl_gene_id', 'external_gene_name'), mart = ensembl.mart.90,values=housekeeping, filters="hgnc_symbol")
hkGenes=as.vector(biomart.results.table[,1])
hkControls=hkGenes[which(hkGenes %in% rownames(y$counts))]

# Volcano plot with points of housekeeping genes
pdf(paste0(outputdir,"VolcanoPlots_dupCorEfit.pdf"), height=15, width=10)
par(mfrow=c(3,1))
for (i in 1:ncol(voomDupEfit)){
    plot(voomDupEfit$coef[,i], -log10(as.matrix(voomDupEfit$p.value)[,i]), pch=20, main=colnames(voomDupEfit)[i], xlab="log2FoldChange", ylab="-log10(pvalue)")
    points(voomDupEfit$coef[,i][which(names(voomDupEfit$coef[,i]) %in% hkControls)], -log10(as.matrix(voomDupEfit$p.value)[,i][which(names(voomDupEfit$coef[,i]) %in% hkControls)]) , pch=20, col=4, xlab="log2FoldChange", ylab="-log10(pvalue)")
    legend("topleft", "genes", "hk genes",fill=4)
    abline(v=c(-1,1))
}
dev.off()

# PCA visualisation after correction and association with covariates ------------------------------------------------------------

# let's also visualise how our PCAs look after limma correction by using removeBatcheffect. Help on design of removeBatcheffects was given by the lovely John Blischak.
design <- model.matrix(~0 + y$samples$Island)
colnames(design)=gsub("Island", "", colnames(design))
colnames(design)=gsub("[\\y$]", "", colnames(design))
colnames(design)=gsub("samples", "", colnames(design))
colnames(design)=gsub("West Papua", "Mappi", colnames(design))
batch.corrected.lcpm <- removeBatchEffect(lcpm, batch=y$samples$batch, covariates = cbind(y$samples$Age, y$samples$RIN, y$samples$CD8T, y$samples$CD4T, y$samples$NK, y$samples$Bcell, y$samples$Mono, y$samples$Gran), design=design)

# define sample names
samplenames <- as.character(y$samples$samples)
samplenames <- sub("([A-Z]{3})([0-9]{3})", "\\1-\\2", samplenames)
samplenames <- sapply(strsplit(samplenames, "[_.]"), `[`, 1)

# get which samples are replicates
load(paste0(inputdir, "covariates.Rda"))
allreps=covariates[,1][which(covariates$replicate)]
allreps=unique(allreps)
allreplicated=as.factor(samplenames %in% allreps)

# assign covariate names
# subtract variables we don't need
subtract=c("group", "norm.factors", "samples")
# get index of unwanted variables
subtract=which(colnames(y$samples) %in% subtract)
covariate.names = colnames(y$samples)[-subtract]
for (name in covariate.names){
 assign(name, y$samples[[paste0(name)]])
}

# Age, RIN, and library size need to be broken up into chunks for easier visualisation of trends (for instance in Age, we want to see high age vs low age rather than the effect of every single age variable)
for (name in c("Age","RIN","lib.size")){
  assign(name, cut(as.numeric(as.character(y$samples[[paste0(name)]])), breaks=5))
}

# assign names to covariate names so you can grab individual elements by name
names(covariate.names)=covariate.names

# assign factor variables
factorVariables=c(colnames(Filter(is.factor,y$samples))[which(colnames(Filter(is.factor,y$samples)) %in% covariate.names)], "Age", "lib.size", "RIN")
numericVariables=colnames(Filter(is.numeric,y$samples))[which(colnames(Filter(is.numeric,y$samples)) %in% covariate.names)] %>% subset(., !(. %in% factorVariables))

# PCA plotting function
plot.pca <- function(dataToPca, speciesCol, namesPch, sampleNames){
    pca <- prcomp(t(dataToPca), scale=T, center=T)
    pca.var <- pca$sdev^2/sum(pca$sdev^2)
    for (i in 1:9){
        pca_axis1=i
        pca_axis2=i+1
        plot(pca$x[,pca_axis1], pca$x[,pca_axis2], col=speciesCol, pch=namesPch, cex=2, xlab=paste0("PC", pca_axis1, " (", round(pca.var[pca_axis1]*100, digits=2), "% of variance)"), ylab=paste0("PC", pca_axis2, " (", round(pca.var[pca_axis2]*100, digits=2), "% of variance)", sep=""), main=name)
        # points(pca$x[,pca_axis1][which(allreplicated==T)], pca$x[,pca_axis2][which(allreplicated==T)], col="black", pch=8, cex=2)
        # text(pca$x[,pca_axis1][which(allreplicated==T)], pca$x[,pca_axis2][which(allreplicated==T)], labels=samplenames[which(allreplicated==T)], pos=3)
        legend(legend=unique(sampleNames), pch=16, x="bottomright", col=unique(speciesCol), cex=0.6, title=name, border=F, bty="n")
        legend(legend=unique(as.numeric(y$samples$batch)), "topright", pch=unique(as.numeric(y$samples$batch)) + 14, title="Batch", cex=0.6, border=F, bty="n")
    }

    return(pca)
}

# PCA association function
pc.assoc <- function(pca.data){
    all.pcs <- data.frame()
    for (i in 1:ncol(pca.data$x)){
        all.assoc <- vector()
        for (j in 1:ncol(all.covars.df)){
            test.assoc <- anova(lm(pca.data$x[,i] ~ all.covars.df[,j]))[1,5]
            all.assoc <- c(all.assoc, test.assoc)
        }
        single.pc <- c(i, all.assoc)
        all.pcs <- rbind(all.pcs, single.pc)
    }
    names(all.pcs) <- c("PC", colnames(all.covars.df))

    print ("Here are the relationships between PCs and some possible covariates")
    print (all.pcs)
    return (all.pcs)
}

# Prepare covariate matrix
all.covars.df <- y$samples[,covariate.names]

# Plot PCA
for (name in factorVariables){
  if (nlevels(get(name)) < 26){
    pdf(paste0(outputdir,"pcaresults_",name,".pdf"))
    pcaresults <- plot.pca(dataToPca=batch.corrected.lcpm, speciesCol=as.numeric(get(name)),namesPch=as.numeric(y$samples$batch) + 14,sampleNames=get(name))
    dev.off()
  } else {
    pdf(paste0(outputdir,"pcaresults_",name,"_RemoveBatchEffect.pdf"))
    pcaresults <- plot.pca(dataToPca=batch.corrected.lcpm, speciesCol=as.numeric(get(name)),namesPch=20,sampleNames=get(name))
    dev.off()
  }
}

# plot batch
pdf(paste0(outputdir,"pcaresults_batch.pdf"))
name="batch"
pcaresults <- plot.pca(dataToPca=batch.corrected.lcpm, speciesCol=batch.col[as.numeric(batch)],namesPch=as.numeric(y$samples$batch) + 14,sampleNames=batch)
dev.off()
  
# plot numeric variables
for (name in numericVariables){
    initial = .bincode(get(name), breaks=seq(min(get(name), na.rm=T), max(get(name), na.rm=T), len = 80),include.lowest = TRUE)
    bloodCol <- colorRampPalette(c("blue", "red"))(79)[initial]
    pdf(paste0(outputdir,"pcaresults_",name,".pdf"))
    pcaresults <- plot.pca(dataToPca=batch.corrected.lcpm, speciesCol=bloodCol,namesPch=as.numeric(y$samples$batch) + 14,sampleNames=get(name))
    legend(legend=c("High","Low"), pch=16, x="bottomright", col=c(bloodCol[which.max(get(name))], bloodCol[which.min(get(name))]), cex=0.6, title=name, border=F, bty="n")
    legend(legend=unique(as.numeric(y$samples$batch)), "topright", pch=unique(as.numeric(y$samples$batch)) + 14, title="Batch", cex=0.6, border=F, bty="n")
    dev.off()
}

# Get PCA associations
all.pcs <- pc.assoc(pcaresults)
all.pcs$Variance <- pcaresults$sdev^2/sum(pcaresults$sdev^2)
write.table(all.pcs, file=paste0(outputdir,"pca_covariates_blood_RNASeqDeconCell.txt"), col.names=T, row.names=F, quote=F, sep="\t")

# get rid of covariates we aren't interested in for the heatmap
covariate.names=covariate.names[grep("lib.size|ID|microscopy.pos|PCR.pos|fract.pfpx.reads|replicate|ind",covariate.names, invert=T)]

# plot pca covariates association matrix to illustrate any remaining confounding/batch
pdf(paste0(outputdir,"significantCovariates_AnovaHeatmap.pdf"))
pheatmap(log(all.pcs[1:5,covariate.names]), cluster_col=F, col= colorRampPalette(brewer.pal(11, "RdYlBu"))(100), cluster_rows=F, main="Significant Covariates \n Anova")
dev.off()

# Summary and visualisation of gene trends ---------------------------------------------------------------------------

dt <- decideTests(voomDupEfit, p.value=0.01, lfc=1)

# plot log2 fold change between islands
pdf(paste0(outputdir,"log2FC_IslandComparisons_pval01_dupCor.pdf"))
# note 'p.value' is the cutoff value for adjusted p-values
topTable <- topTable(voomDupEfit, coef=1, n=Inf, p.value=0.01)
plot(density(topTable$logFC), col=9, xlim=c(-2,2), main="LogFC Density", xlab="LogFC", ylab="Density")
abline(v=c(-1,-0.5,0.5,1), lty=3)
counter=0
for (i in 2:ncol(voomDupEfit)){
    counter=counter+1
    topTable <- topTable(voomDupEfit, coef=i, n=Inf, p.value=0.01)
    lines(density(topTable$logFC), col=9+counter, xlim=c(-2,2))
}
legend(x="topright", bty="n", col=9:11, legend=colnames(voomDupEfit), lty=1, lwd=2)
dev.off()

# graphical representation of DE results through MD plot
pdf(paste0(outputdir,"MD_Plots_pval01_lfc1_dupCor.pdf"), height=15, width=10)
par(mfrow=c(3,1))
for (i in 1:ncol(voomDupEfit)){
    o <- which(names(voomDupEfit$Amean) %in% names(which(abs(dt[,i])==1)))
    x <- voomDupEfit$Amean
    z <- voomDupEfit$coefficients[,i]
    t=which(names(voomDupEfit$coefficients[,i]) %in% names(which(abs(dt[,i])==1)))
    G <- voomDupEfit$genes[which(abs(dt[,i])==1),]$SYMBOL
    plotMD(voomDupEfit, column=i, status=dt[,i], main=colnames(voomDupEfit)[i], hl.col=c("blue","red"), values=c(-1,1))
    abline(h=c(1,-1), lty=2)
    legend(legend=paste(names(summary(dt)[,i]), summary(dt)[,i], sep="="), x="bottomright", border=F, bty="n")
    text(x[o], z[t], labels=G)
}
dev.off()

# We can also look at the top ten DE genes with a heatmap of logCPM values for the top 100 genes. Each gene (or row) is scaled so that mean expression is zero and the standard deviation is one (we're using 'E' from the voom object which is a numeric matrix of normalized expression values on the log2 scale). Samples with relatively high expression of a given gene are marked in red and samples with relatively low expression are marked in blue. Lighter shades and white represent genes with intermediate expression levels. Samples and genes are reordered by the method of hierarchical clustering
# first, make a heatmap of all top genes in one pdf

# set up annotation
col_fun = colorRamp2(c(-4, 0, 4), c("blue", "white", "red"))

df1=data.frame(island = as.character(Island))
df2=data.frame(batch = as.numeric(batch))
ha1 = HeatmapAnnotation(df = df1, col = list(island = c("Mentawai" =  1, "Sumba" = 2, "West Papua" = 3)))

pdf(paste0(outputdir,"HeatmapAllPops_dupCor.pdf"), height=12, width=15)
# We can also make individual pdfs of the top genes
island1=c("Sumba","Mentawai","West Papua")
island2=c("Sumba","Mentawai","West Papua")

counter=0

grid.newpage()
pushViewport(viewport(layout = grid.layout(nr = 2, nc = 2)))
# set up layout row position
layout.row=c(1,1,2)
# set up column position
layout.col=c(1,2,1)

# get annotation for gene names
edb <- EnsDb.Hsapiens.v86

for (i1 in island1){
    island2=island2[-1]
    for (i2 in island2){
        counter=counter+1
        topTable <- topTable(voomDupEfit, coef=counter, p.value=0.01, lfc=1, n=Inf, sort.by="p")
        index <- which(vDup$genes$ENSEMBL %in% topTable$ENSEMBL[1:10])
        pushViewport(viewport(layout.pos.row = layout.row[counter], layout.pos.col = layout.col[counter]))
        df=data.frame(island = as.character(Island[grep(paste(i1,i2,sep="|"), Island)]))
        ha =  HeatmapAnnotation(df = df, col = list(island = c("Mentawai" =  1, "Sumba" = 2, "West Papua" = 3)))
        transformedHeatmap=t(scale(t(vDup$E[index,])))[,grep(paste(i1,i2,sep="|"), Island)]
        genesymbol <- select(edb, keys=rownames(transformedHeatmap), columns=c("SYMBOL"), keytype="GENEID")$SYMBOL
        rownames(transformedHeatmap)=genesymbol
        draw(Heatmap(transformedHeatmap, col=col_fun, column_title = colnames(voomDupEfit)[counter], top_annotation = ha, show_row_names = T, show_heatmap_legend = F, show_column_names = F, name = "Z-Score"),show_annotation_legend = TRUE,newpage=F)
        upViewport()
    }
}

lgd = Legend(at = c(-4,0,4), title = "Row Z-Score", col_fun = col_fun, grid_height = unit(1, "cm"), grid_width = unit(10, "mm"))
lgd2 = Legend(at = c(1,2,3), legend_gp = gpar(fill = 1:3), labels=c("Mentawai", "Sumba","West Papua"),title = "Island", grid_height = unit(1, "cm"), grid_width = unit(10, "mm"))
pd = packLegend(lgd, lgd2, direction = "horizontal")

pushViewport(viewport(layout.pos.row = 2, layout.pos.col = 2))
grid.draw(pd)
upViewport()
dev.off()

# show the number of DE genes between all islands
pdf(paste0(outputdir,"vennDiagram_allSigDEGenes_pval01_FDR1_dupCor.pdf"), height=15, width=15)
vennDiagram(dt[,1:3], circle.col=c(9,10,11))
dev.off()


# get DE genes in common with populations compared to Mappi, i.e., SMBvsMPI and MTWvsMPI (since we think this is an interesting island comparison)
rownames(voomDupEfit$genes)=voomDupEfit$genes$ENSEMBL
de.common.MPI = which(dt[,2]!=0 & dt[,3]!=0)
# get what these genes are doing and save them to a file
commonGenes.MPI <- getBM(attributes = c('ensembl_gene_id', 'external_gene_name', 'description', "interpro","interpro_description"), mart = ensembl.mart.90,values=names(de.common.MPI), filters="ensembl_gene_id")
# save the common gene names 
de.common.MPI=voomDupEfit$genes[names(de.common.MPI),]
write.table(de.common.MPI, file=paste0(outputdir,"allCommonGenes_MPI_dupcor.txt"))


# now plot the common genes to see if they're being regulated in the same direction
tt.SMBvsMPI=topTable(voomDupEfit, coef=2, p.value=0.01, n=Inf, lfc=1, sort.by="p")
tt.MTWvsMPI=topTable(voomDupEfit, coef=3, p.value=0.01, n=Inf, lfc=1, sort.by="p")
pdf(paste0(outputdir,"logFC_commonMPIgenes_dupCor.pdf"))
plot(tt.SMBvsMPI[rownames(de.common.MPI),"logFC"], tt.MTWvsMPI[rownames(de.common.MPI),"logFC"], xlab="logFC SMBvsMPI", ylab="logFC MTWvsMPI", pch=20, main="Common DE Genes", xlim=c(-5,5), ylim=c(-6,6))
text(tt.SMBvsMPI[rownames(de.common.MPI),"logFC"], tt.MTWvsMPI[rownames(de.common.MPI),"logFC"], labels=tt.SMBvsMPI[rownames(de.common.MPI),"SYMBOL"], pos=3)
abline(h=0,v=0, lty=2)
dev.off()

# top ranked genes -----------------------------------------------------------------------------------------

# Let's see how the expression levels of all of the significantly DE genes in population comparisons with Mappi are distributed within each island. First, assign our top genes and ensembl IDs to variables
topGenes=de.common.MPI[,2]
topEnsembl=de.common.MPI[,1]

# To visualise distributions, we'll be making violin plots using ggpubr which needs p-value labels. Let's go ahead and make a matrix to input this into ggpubr
# first set up matrix
topGenes.pvalue=matrix(nrow=length(topEnsembl), ncol=ncol(voomDupEfit))
rownames(topGenes.pvalue)=topEnsembl
colnames(topGenes.pvalue)=colnames(voomDupEfit)
for (i in 1:ncol(voomDupEfit)){
    # get significant genes over a logFC of 1 for all Island comparisons
    topTable <- topTable(voomDupEfit, coef=i, n=Inf)
    for(j in topEnsembl){
        # input the adjusted p.value for each gene
        topGenes.pvalue[j,i]=topTable[j,"adj.P.Val"]
    }
}

# make pvalues into scientific notation with max 3 digits
topGenes.pvalue=formatC(topGenes.pvalue, format="e", digits=2, drop0trailing=T)
# convert e notation to base 10 notation
topGenes.pvalue=sub("e", "x10^", topGenes.pvalue)

# reset ensemble row names to gene symbols
rownames(vDup$E)=vDup$genes$SYMBOL

# We can make the violin plots using ggpubr
pdf(paste0(outputdir,"TopGenes_ggboxplot_Island.pdf"), height=8, width=10)
counter=0
for(ensembl in topEnsembl){
    counter=counter+1
    gene.df <- data.frame(vDup$E[which(vDup$genes$ENSEMBL==ensembl),],Island)
    colnames(gene.df)=c("CPM", "Island")
    annotation_df <- data.frame(start=c("Sumba","Sumba", "Mentawai"), end=c("Mentawai","West Papua","West Papua"), y=c(max(gene.df[,1]+4),max(gene.df[,1]+5),max(gene.df[,1]+6)), label=paste("limma p-value =",topGenes.pvalue[ensembl,],sep=" "))
    print(ggviolin(gene.df, x = "Island", y = "CPM", fill="Island", add=c("jitter","boxplot"), main=topGenes[counter], palette=1:3, add.params = c(list(fill = "white"), list(width=0.05))) + geom_signif(data=annotation_df,aes(xmin=start, xmax=end, annotations=label, y_position=y),textsize = 5, vjust = -0.2,manual=TRUE) + ylim(NA, max(gene.df[,1])+7))
}
dev.off()

# after analysing the distributions and reading up on some of the genes, my three favourite genes are Siglec6, Siglec7, and MARCO. Lets plot out the distribution solely for these three genes
favGenes=c("SIGLEC6","SIGLEC7","MARCO","SOX5","ABCB4","TNFSF4")
favEnsembl=de.common.MPI[,1][sapply(1:length(favGenes), function(x) grep(favGenes[x],de.common.MPI[,2]))]

# set up pvalue matrix
topGenes.pvalue=matrix(nrow=length(favEnsembl), ncol=ncol(voomDupEfit))
rownames(topGenes.pvalue)=favEnsembl
colnames(topGenes.pvalue)=colnames(voomDupEfit)
for (i in 1:ncol(voomDupEfit)){
    # get significant genes over a logFC of 1 for all Island comparisons
    topTable <- topTable(voomDupEfit, coef=i, n=Inf)
    for(j in favEnsembl){
        # input the adjusted p.value for each gene
        topGenes.pvalue[j,i]=topTable[j,"adj.P.Val"]
    }
}

# make pvalues into scientific notation with max 3 digits
topGenes.pvalue=formatC(topGenes.pvalue, format="e", digits=2, drop0trailing=T)
# convert e notation to base 10 notation
topGenes.pvalue=sub("e", "x10^", topGenes.pvalue)

# We can make the violin plots using ggpubr
counter=0
for(ensembl in favEnsembl){
    counter=counter+1
    # pdf(paste0("FavouriteGenes_ggboxplot_",favGenes[counter],".pdf"), height=8, width=10)
    gene.df <- data.frame(vDup$E[which(vDup$genes$ENSEMBL==ensembl),],Island)
    colnames(gene.df)=c("CPM", "Island")
    annotation_df <- data.frame(start=c("Sumba","Sumba", "Mentawai"), end=c("Mentawai","West Papua","West Papua"), y=c(max(gene.df[,1]+4),max(gene.df[,1]+5),max(gene.df[,1]+6)), label=paste("limma p-value =",topGenes.pvalue[ensembl,],sep=" "))
    # print(ggviolin(gene.df, x = "Island", y = "CPM", fill="Island", add=c("jitter","boxplot"), main=favGenes[counter], palette=1:3, add.params = c(list(fill = "white"), list(width=0.05))) + geom_signif(data=annotation_df,aes(xmin=start, xmax=end, annotations=label, y_position=y),textsize = 5, vjust = -0.2,manual=TRUE) + ylim(NA, max(gene.df[,1])+7))
    assign(favGenes[counter], ggviolin(gene.df, x = "Island", y = "CPM", fill="Island", add=c("jitter","boxplot"), main=favGenes[counter], palette=1:3, add.params = c(list(fill = "white"), list(width=0.05))) + geom_signif(data=annotation_df,aes(xmin=start, xmax=end, annotations=label, y_position=y),textsize = 3, vjust = -0.2,manual=TRUE) + ylim(NA, max(gene.df[,1])+7))
}

pdf(paste0(outputdir,"favouriteTopGenes_distribution_Island.pdf"), height=12, width=15)
ggarrange(SIGLEC6,SIGLEC7,MARCO,SOX5,ABCB4,TNFSF4)
dev.off()

# finally, get logFC thresholds
logFC.df=matrix(nrow=3,ncol=3)
colnames(logFC.df)=colnames(voomDupEfit)
counter=0
for (number in c(0,0.5,1)){
    counter=counter+1
    dt <- decideTests(voomDupEfit, p.value=0.01, lfc=number)
    values=c(sum(abs(dt[,1])), sum(abs(dt[,2])), sum(abs(dt[,3])))
    logFC.df[counter,]=values
}
logFC.df=cbind(logFC = c(0,0.5,1), logFC.df)
write.table(logFC.df, file=paste0(outputdir,"logFC_thresholds.txt"))



